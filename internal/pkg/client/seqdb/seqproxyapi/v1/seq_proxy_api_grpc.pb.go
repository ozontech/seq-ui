// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.4.0
// - protoc             v6.33.4
// source: v1/seq_proxy_api.proto

package seqproxyapi

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.62.0 or later.
const _ = grpc.SupportPackageIsVersion8

const (
	SeqProxyApi_Search_FullMethodName                 = "/seqproxyapi.v1.SeqProxyApi/Search"
	SeqProxyApi_ComplexSearch_FullMethodName          = "/seqproxyapi.v1.SeqProxyApi/ComplexSearch"
	SeqProxyApi_GetAggregation_FullMethodName         = "/seqproxyapi.v1.SeqProxyApi/GetAggregation"
	SeqProxyApi_GetHistogram_FullMethodName           = "/seqproxyapi.v1.SeqProxyApi/GetHistogram"
	SeqProxyApi_Fetch_FullMethodName                  = "/seqproxyapi.v1.SeqProxyApi/Fetch"
	SeqProxyApi_Mapping_FullMethodName                = "/seqproxyapi.v1.SeqProxyApi/Mapping"
	SeqProxyApi_Status_FullMethodName                 = "/seqproxyapi.v1.SeqProxyApi/Status"
	SeqProxyApi_Export_FullMethodName                 = "/seqproxyapi.v1.SeqProxyApi/Export"
	SeqProxyApi_StartAsyncSearch_FullMethodName       = "/seqproxyapi.v1.SeqProxyApi/StartAsyncSearch"
	SeqProxyApi_FetchAsyncSearchResult_FullMethodName = "/seqproxyapi.v1.SeqProxyApi/FetchAsyncSearchResult"
	SeqProxyApi_CancelAsyncSearch_FullMethodName      = "/seqproxyapi.v1.SeqProxyApi/CancelAsyncSearch"
	SeqProxyApi_DeleteAsyncSearch_FullMethodName      = "/seqproxyapi.v1.SeqProxyApi/DeleteAsyncSearch"
	SeqProxyApi_GetAsyncSearchesList_FullMethodName   = "/seqproxyapi.v1.SeqProxyApi/GetAsyncSearchesList"
)

// SeqProxyApiClient is the client API for SeqProxyApi service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// seq-db public api. Exposes APIs related to document querying.
type SeqProxyApiClient interface {
	// Fetch documents for given SearchQuery.
	Search(ctx context.Context, in *SearchRequest, opts ...grpc.CallOption) (*SearchResponse, error)
	// Fetch documents, aggregations and histograms for given queries correspondingly.
	ComplexSearch(ctx context.Context, in *ComplexSearchRequest, opts ...grpc.CallOption) (*ComplexSearchResponse, error)
	// Fetch aggregations for given SearchQuery and AggQueries.
	GetAggregation(ctx context.Context, in *GetAggregationRequest, opts ...grpc.CallOption) (*GetAggregationResponse, error)
	// Fetch histogram for given SearchQuery and HistQuery.
	GetHistogram(ctx context.Context, in *GetHistogramRequest, opts ...grpc.CallOption) (*GetHistogramResponse, error)
	// Fetch documents by the corresponding seq-ids.
	Fetch(ctx context.Context, in *FetchRequest, opts ...grpc.CallOption) (SeqProxyApi_FetchClient, error)
	// Fetch current seq-db mapping.
	Mapping(ctx context.Context, in *MappingRequest, opts ...grpc.CallOption) (*MappingResponse, error)
	// Fetch seq-db store's availability information.
	Status(ctx context.Context, in *StatusRequest, opts ...grpc.CallOption) (*StatusResponse, error)
	// Stream documents for given SearchQuery. Same as Search, but returns streaming response.
	Export(ctx context.Context, in *ExportRequest, opts ...grpc.CallOption) (SeqProxyApi_ExportClient, error)
	// Starts a new asynchronous search operation.
	// The server processes the request in the background and returns a search ID.
	StartAsyncSearch(ctx context.Context, in *StartAsyncSearchRequest, opts ...grpc.CallOption) (*StartAsyncSearchResponse, error)
	// Fetches the result or current status of a previously started async search.
	// Clients should use the search ID returned by StartAsyncSearch.
	FetchAsyncSearchResult(ctx context.Context, in *FetchAsyncSearchResultRequest, opts ...grpc.CallOption) (*FetchAsyncSearchResultResponse, error)
	// Cancels an ongoing asynchronous search operation if it hasn't completed yet.
	CancelAsyncSearch(ctx context.Context, in *CancelAsyncSearchRequest, opts ...grpc.CallOption) (*CancelAsyncSearchResponse, error)
	// Frees up resources if the result is no longer needed.
	DeleteAsyncSearch(ctx context.Context, in *DeleteAsyncSearchRequest, opts ...grpc.CallOption) (*DeleteAsyncSearchResponse, error)
	// Fetch list of async searches.
	GetAsyncSearchesList(ctx context.Context, in *GetAsyncSearchesListRequest, opts ...grpc.CallOption) (*GetAsyncSearchesListResponse, error)
}

type seqProxyApiClient struct {
	cc grpc.ClientConnInterface
}

func NewSeqProxyApiClient(cc grpc.ClientConnInterface) SeqProxyApiClient {
	return &seqProxyApiClient{cc}
}

func (c *seqProxyApiClient) Search(ctx context.Context, in *SearchRequest, opts ...grpc.CallOption) (*SearchResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(SearchResponse)
	err := c.cc.Invoke(ctx, SeqProxyApi_Search_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *seqProxyApiClient) ComplexSearch(ctx context.Context, in *ComplexSearchRequest, opts ...grpc.CallOption) (*ComplexSearchResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ComplexSearchResponse)
	err := c.cc.Invoke(ctx, SeqProxyApi_ComplexSearch_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *seqProxyApiClient) GetAggregation(ctx context.Context, in *GetAggregationRequest, opts ...grpc.CallOption) (*GetAggregationResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetAggregationResponse)
	err := c.cc.Invoke(ctx, SeqProxyApi_GetAggregation_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *seqProxyApiClient) GetHistogram(ctx context.Context, in *GetHistogramRequest, opts ...grpc.CallOption) (*GetHistogramResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetHistogramResponse)
	err := c.cc.Invoke(ctx, SeqProxyApi_GetHistogram_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *seqProxyApiClient) Fetch(ctx context.Context, in *FetchRequest, opts ...grpc.CallOption) (SeqProxyApi_FetchClient, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &SeqProxyApi_ServiceDesc.Streams[0], SeqProxyApi_Fetch_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &seqProxyApiFetchClient{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type SeqProxyApi_FetchClient interface {
	Recv() (*Document, error)
	grpc.ClientStream
}

type seqProxyApiFetchClient struct {
	grpc.ClientStream
}

func (x *seqProxyApiFetchClient) Recv() (*Document, error) {
	m := new(Document)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *seqProxyApiClient) Mapping(ctx context.Context, in *MappingRequest, opts ...grpc.CallOption) (*MappingResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(MappingResponse)
	err := c.cc.Invoke(ctx, SeqProxyApi_Mapping_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *seqProxyApiClient) Status(ctx context.Context, in *StatusRequest, opts ...grpc.CallOption) (*StatusResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(StatusResponse)
	err := c.cc.Invoke(ctx, SeqProxyApi_Status_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *seqProxyApiClient) Export(ctx context.Context, in *ExportRequest, opts ...grpc.CallOption) (SeqProxyApi_ExportClient, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &SeqProxyApi_ServiceDesc.Streams[1], SeqProxyApi_Export_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &seqProxyApiExportClient{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type SeqProxyApi_ExportClient interface {
	Recv() (*ExportResponse, error)
	grpc.ClientStream
}

type seqProxyApiExportClient struct {
	grpc.ClientStream
}

func (x *seqProxyApiExportClient) Recv() (*ExportResponse, error) {
	m := new(ExportResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *seqProxyApiClient) StartAsyncSearch(ctx context.Context, in *StartAsyncSearchRequest, opts ...grpc.CallOption) (*StartAsyncSearchResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(StartAsyncSearchResponse)
	err := c.cc.Invoke(ctx, SeqProxyApi_StartAsyncSearch_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *seqProxyApiClient) FetchAsyncSearchResult(ctx context.Context, in *FetchAsyncSearchResultRequest, opts ...grpc.CallOption) (*FetchAsyncSearchResultResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(FetchAsyncSearchResultResponse)
	err := c.cc.Invoke(ctx, SeqProxyApi_FetchAsyncSearchResult_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *seqProxyApiClient) CancelAsyncSearch(ctx context.Context, in *CancelAsyncSearchRequest, opts ...grpc.CallOption) (*CancelAsyncSearchResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CancelAsyncSearchResponse)
	err := c.cc.Invoke(ctx, SeqProxyApi_CancelAsyncSearch_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *seqProxyApiClient) DeleteAsyncSearch(ctx context.Context, in *DeleteAsyncSearchRequest, opts ...grpc.CallOption) (*DeleteAsyncSearchResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DeleteAsyncSearchResponse)
	err := c.cc.Invoke(ctx, SeqProxyApi_DeleteAsyncSearch_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *seqProxyApiClient) GetAsyncSearchesList(ctx context.Context, in *GetAsyncSearchesListRequest, opts ...grpc.CallOption) (*GetAsyncSearchesListResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetAsyncSearchesListResponse)
	err := c.cc.Invoke(ctx, SeqProxyApi_GetAsyncSearchesList_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// SeqProxyApiServer is the server API for SeqProxyApi service.
// All implementations should embed UnimplementedSeqProxyApiServer
// for forward compatibility
//
// seq-db public api. Exposes APIs related to document querying.
type SeqProxyApiServer interface {
	// Fetch documents for given SearchQuery.
	Search(context.Context, *SearchRequest) (*SearchResponse, error)
	// Fetch documents, aggregations and histograms for given queries correspondingly.
	ComplexSearch(context.Context, *ComplexSearchRequest) (*ComplexSearchResponse, error)
	// Fetch aggregations for given SearchQuery and AggQueries.
	GetAggregation(context.Context, *GetAggregationRequest) (*GetAggregationResponse, error)
	// Fetch histogram for given SearchQuery and HistQuery.
	GetHistogram(context.Context, *GetHistogramRequest) (*GetHistogramResponse, error)
	// Fetch documents by the corresponding seq-ids.
	Fetch(*FetchRequest, SeqProxyApi_FetchServer) error
	// Fetch current seq-db mapping.
	Mapping(context.Context, *MappingRequest) (*MappingResponse, error)
	// Fetch seq-db store's availability information.
	Status(context.Context, *StatusRequest) (*StatusResponse, error)
	// Stream documents for given SearchQuery. Same as Search, but returns streaming response.
	Export(*ExportRequest, SeqProxyApi_ExportServer) error
	// Starts a new asynchronous search operation.
	// The server processes the request in the background and returns a search ID.
	StartAsyncSearch(context.Context, *StartAsyncSearchRequest) (*StartAsyncSearchResponse, error)
	// Fetches the result or current status of a previously started async search.
	// Clients should use the search ID returned by StartAsyncSearch.
	FetchAsyncSearchResult(context.Context, *FetchAsyncSearchResultRequest) (*FetchAsyncSearchResultResponse, error)
	// Cancels an ongoing asynchronous search operation if it hasn't completed yet.
	CancelAsyncSearch(context.Context, *CancelAsyncSearchRequest) (*CancelAsyncSearchResponse, error)
	// Frees up resources if the result is no longer needed.
	DeleteAsyncSearch(context.Context, *DeleteAsyncSearchRequest) (*DeleteAsyncSearchResponse, error)
	// Fetch list of async searches.
	GetAsyncSearchesList(context.Context, *GetAsyncSearchesListRequest) (*GetAsyncSearchesListResponse, error)
}

// UnimplementedSeqProxyApiServer should be embedded to have forward compatible implementations.
type UnimplementedSeqProxyApiServer struct {
}

func (UnimplementedSeqProxyApiServer) Search(context.Context, *SearchRequest) (*SearchResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Search not implemented")
}
func (UnimplementedSeqProxyApiServer) ComplexSearch(context.Context, *ComplexSearchRequest) (*ComplexSearchResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ComplexSearch not implemented")
}
func (UnimplementedSeqProxyApiServer) GetAggregation(context.Context, *GetAggregationRequest) (*GetAggregationResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetAggregation not implemented")
}
func (UnimplementedSeqProxyApiServer) GetHistogram(context.Context, *GetHistogramRequest) (*GetHistogramResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetHistogram not implemented")
}
func (UnimplementedSeqProxyApiServer) Fetch(*FetchRequest, SeqProxyApi_FetchServer) error {
	return status.Errorf(codes.Unimplemented, "method Fetch not implemented")
}
func (UnimplementedSeqProxyApiServer) Mapping(context.Context, *MappingRequest) (*MappingResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Mapping not implemented")
}
func (UnimplementedSeqProxyApiServer) Status(context.Context, *StatusRequest) (*StatusResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Status not implemented")
}
func (UnimplementedSeqProxyApiServer) Export(*ExportRequest, SeqProxyApi_ExportServer) error {
	return status.Errorf(codes.Unimplemented, "method Export not implemented")
}
func (UnimplementedSeqProxyApiServer) StartAsyncSearch(context.Context, *StartAsyncSearchRequest) (*StartAsyncSearchResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method StartAsyncSearch not implemented")
}
func (UnimplementedSeqProxyApiServer) FetchAsyncSearchResult(context.Context, *FetchAsyncSearchResultRequest) (*FetchAsyncSearchResultResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method FetchAsyncSearchResult not implemented")
}
func (UnimplementedSeqProxyApiServer) CancelAsyncSearch(context.Context, *CancelAsyncSearchRequest) (*CancelAsyncSearchResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CancelAsyncSearch not implemented")
}
func (UnimplementedSeqProxyApiServer) DeleteAsyncSearch(context.Context, *DeleteAsyncSearchRequest) (*DeleteAsyncSearchResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteAsyncSearch not implemented")
}
func (UnimplementedSeqProxyApiServer) GetAsyncSearchesList(context.Context, *GetAsyncSearchesListRequest) (*GetAsyncSearchesListResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetAsyncSearchesList not implemented")
}

// UnsafeSeqProxyApiServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to SeqProxyApiServer will
// result in compilation errors.
type UnsafeSeqProxyApiServer interface {
	mustEmbedUnimplementedSeqProxyApiServer()
}

func RegisterSeqProxyApiServer(s grpc.ServiceRegistrar, srv SeqProxyApiServer) {
	s.RegisterService(&SeqProxyApi_ServiceDesc, srv)
}

func _SeqProxyApi_Search_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SearchRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SeqProxyApiServer).Search(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: SeqProxyApi_Search_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SeqProxyApiServer).Search(ctx, req.(*SearchRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _SeqProxyApi_ComplexSearch_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ComplexSearchRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SeqProxyApiServer).ComplexSearch(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: SeqProxyApi_ComplexSearch_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SeqProxyApiServer).ComplexSearch(ctx, req.(*ComplexSearchRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _SeqProxyApi_GetAggregation_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetAggregationRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SeqProxyApiServer).GetAggregation(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: SeqProxyApi_GetAggregation_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SeqProxyApiServer).GetAggregation(ctx, req.(*GetAggregationRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _SeqProxyApi_GetHistogram_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetHistogramRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SeqProxyApiServer).GetHistogram(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: SeqProxyApi_GetHistogram_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SeqProxyApiServer).GetHistogram(ctx, req.(*GetHistogramRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _SeqProxyApi_Fetch_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(FetchRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(SeqProxyApiServer).Fetch(m, &seqProxyApiFetchServer{ServerStream: stream})
}

type SeqProxyApi_FetchServer interface {
	Send(*Document) error
	grpc.ServerStream
}

type seqProxyApiFetchServer struct {
	grpc.ServerStream
}

func (x *seqProxyApiFetchServer) Send(m *Document) error {
	return x.ServerStream.SendMsg(m)
}

func _SeqProxyApi_Mapping_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MappingRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SeqProxyApiServer).Mapping(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: SeqProxyApi_Mapping_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SeqProxyApiServer).Mapping(ctx, req.(*MappingRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _SeqProxyApi_Status_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(StatusRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SeqProxyApiServer).Status(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: SeqProxyApi_Status_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SeqProxyApiServer).Status(ctx, req.(*StatusRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _SeqProxyApi_Export_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(ExportRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(SeqProxyApiServer).Export(m, &seqProxyApiExportServer{ServerStream: stream})
}

type SeqProxyApi_ExportServer interface {
	Send(*ExportResponse) error
	grpc.ServerStream
}

type seqProxyApiExportServer struct {
	grpc.ServerStream
}

func (x *seqProxyApiExportServer) Send(m *ExportResponse) error {
	return x.ServerStream.SendMsg(m)
}

func _SeqProxyApi_StartAsyncSearch_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(StartAsyncSearchRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SeqProxyApiServer).StartAsyncSearch(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: SeqProxyApi_StartAsyncSearch_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SeqProxyApiServer).StartAsyncSearch(ctx, req.(*StartAsyncSearchRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _SeqProxyApi_FetchAsyncSearchResult_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FetchAsyncSearchResultRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SeqProxyApiServer).FetchAsyncSearchResult(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: SeqProxyApi_FetchAsyncSearchResult_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SeqProxyApiServer).FetchAsyncSearchResult(ctx, req.(*FetchAsyncSearchResultRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _SeqProxyApi_CancelAsyncSearch_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CancelAsyncSearchRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SeqProxyApiServer).CancelAsyncSearch(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: SeqProxyApi_CancelAsyncSearch_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SeqProxyApiServer).CancelAsyncSearch(ctx, req.(*CancelAsyncSearchRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _SeqProxyApi_DeleteAsyncSearch_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteAsyncSearchRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SeqProxyApiServer).DeleteAsyncSearch(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: SeqProxyApi_DeleteAsyncSearch_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SeqProxyApiServer).DeleteAsyncSearch(ctx, req.(*DeleteAsyncSearchRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _SeqProxyApi_GetAsyncSearchesList_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetAsyncSearchesListRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SeqProxyApiServer).GetAsyncSearchesList(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: SeqProxyApi_GetAsyncSearchesList_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SeqProxyApiServer).GetAsyncSearchesList(ctx, req.(*GetAsyncSearchesListRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// SeqProxyApi_ServiceDesc is the grpc.ServiceDesc for SeqProxyApi service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var SeqProxyApi_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "seqproxyapi.v1.SeqProxyApi",
	HandlerType: (*SeqProxyApiServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Search",
			Handler:    _SeqProxyApi_Search_Handler,
		},
		{
			MethodName: "ComplexSearch",
			Handler:    _SeqProxyApi_ComplexSearch_Handler,
		},
		{
			MethodName: "GetAggregation",
			Handler:    _SeqProxyApi_GetAggregation_Handler,
		},
		{
			MethodName: "GetHistogram",
			Handler:    _SeqProxyApi_GetHistogram_Handler,
		},
		{
			MethodName: "Mapping",
			Handler:    _SeqProxyApi_Mapping_Handler,
		},
		{
			MethodName: "Status",
			Handler:    _SeqProxyApi_Status_Handler,
		},
		{
			MethodName: "StartAsyncSearch",
			Handler:    _SeqProxyApi_StartAsyncSearch_Handler,
		},
		{
			MethodName: "FetchAsyncSearchResult",
			Handler:    _SeqProxyApi_FetchAsyncSearchResult_Handler,
		},
		{
			MethodName: "CancelAsyncSearch",
			Handler:    _SeqProxyApi_CancelAsyncSearch_Handler,
		},
		{
			MethodName: "DeleteAsyncSearch",
			Handler:    _SeqProxyApi_DeleteAsyncSearch_Handler,
		},
		{
			MethodName: "GetAsyncSearchesList",
			Handler:    _SeqProxyApi_GetAsyncSearchesList_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "Fetch",
			Handler:       _SeqProxyApi_Fetch_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "Export",
			Handler:       _SeqProxyApi_Export_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "v1/seq_proxy_api.proto",
}
